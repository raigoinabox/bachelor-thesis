Programming language is a formal language with a set of rules about how the computer should behave. The syntax of the language is usually considered the grammar of the language. For example, if there is a syntax problem in the program, the computer doesn't understand the command and stops. The semantics of the language is considered to be the vocabulary and meaning of the language. If there is a semantical problem, then the program is valid and understandable to the computer, but it is not what the programmer wished to happen. The program will react rather unpredictably. Syntactic sugar is a feature that the programmer can easily implement it in the language and is there for the convenience.

Since a programming language is only a set of rules, it needs an implementation. An implementation is a program that evaluates the syntax into machine actions. There are usually multiple ways to implement this. The most direct approach is to use interpretation, which parses the source code and performs the instructions directly. A second approach is to compile the program, which translates the source code into machine code and optimises it, and then run it. It is also possibe to compile a language into another language and then run from that language's implementation. A compiled program will usually run faster, because the program can be heavily optimised, but compiling the program may take some time. This disadvantage doesn't usually reach the user, because the programmer compiles the program before  publishing the machine code to the user. The user can then choose the right file for its computer architecture. Compiling to a lower language has the advantage that the work of adapting for different processor architectures and optimising is already done, but it is possible to compile to a too general source code, which leads to less optimisations.

A third approach is to use just-in-time (JIT) compilation. JIT takes a hybrid approach between running it raw and compiling. While running the program, the JIT compiler will observe what parts of the program are most often run and will compile those parts. Because the analysation is fairly complex and runs parallel to the execution of the program, JIT compilers take a lot more memory[25]. The advantages are that the first operations start immediately and long programs still run almost as efficiently as a precompiled program. The disadvantages are the high memory usage and sudden pauses in the program execution while the necessary part is being compiled.
Programming languages are usually divided into two categories: high level languages and low level languages. The difference is that low level languages are designed more around how the computer works, while high level languages are designed more around the productivity of the programmer. Because high level languages need to do more translation between what the programmer wants and what the computer accepts, they are usually slower than low level languages. Another advantage of lower level languages is that they enable the programmer to have better access to specific operations and more understanding how the program is executed. This is very useful when the main goal is optimisation.

Another way to divide programming languages is static and dynamic programming languages. A programming language is considered static if it uses static typing. Static typing means that the type of a variable is determined prior to the execution of the program. This way the program doesn't have to check the type of a variable at the time of the execution and, therefore, can run faster. Dynamic typing holds the advantage that a variable can hold different types of values at different times and that types can be changed at runtime.

\subsubsection{Procedural programming}
Imperative programming is a style of programming with the philosophy of changing the machine's state to the required state, which could be a file in a hard drive or a video on the screen. For that the computer executes a sequence of operations in order, which are specified by the programmer. An operation is some change of state in the computer or calculation of some data.

Procedural programming is a subset of imperative programming. Procedural programming tries to divide the program into variables, data structures and procedures. Procedures are meant to group together abstract operations so they could be reused in different situations. In this case an operation can also be a procedure. Data structures are meant to group together conjoined data so they could be moved and manipulated more easily. Variables are pointers to data. They point to the location of the data in the memory which can be then easily retrieved.

\subsubsection{Object-oriented programming}
Object-oriented programming is another subset of imperative programming. Object-oriented programming tries to divide the program into objects that communicate with each other. Each object has fields and methods. Fields and methods are similar to variables and procedures, but they are tied to the object. Fields are considered to be the objects inner state and methods are considered to be the object's behaviour or object's interface.

The goal of object-oriented programming is encapsulation. Encapsulation means that each object has an inner state, inner behaviour and an interface for other objects to use. An outer object doesn't need to know what is happening within the object. It only needs to know how the object is going to react to an interface procedure. Access protection modifiers are generally employed to better enforce this behaviour. These modifiers are usually tied to a method or field and they describe what other methods are allowed to access these methods or fields. Right to access a field means the right to read or change the field and right to access a method means the right to run the method[26]. An object's methods always have access to its objects fields.

An object can inherit another object. The inheriting object is called subobject and the inherited object is called the superobject. The subobject gets the superobject's fields and methods. A copy of the superobject is created and retained in the subobject. When searching for the subobject's methods or fields and they are not found then the superobject is searched for the field or method. A subobject doesn't automatically have access to the superobject's private fields and methods. The subobject can override the superobject's public methods. The type signature of the method cannot change, but the content or the action of the method is changed.

\emph{The classic way to implement object-oriented programming is with classes.} In class-based programming the object is separated into the class and the instance. The class is an abstraction and the classification of the object while the instance is a actual object with actual data. Usually the class holds the behaviour of the object, which includes the constructor. The constructor is a special method, that is called when a new instance is being created from the object. Inheritance works by remembering the inheritance line and then searching for the methods in the right class.

An interface is a a class that has no fields and all its methods are public. All of the methods are abstract methods, meaning that the methods have no content or implementation. A class can usually implement multiple interfaces but inherit from only one class. One can't make a instance of an interface, there needs to be an implementing class. An abstract class is a class that has atleast one abstract method. Similar to interfaces, it is impossible to make an instance of them. However they are still classes and and they are inherited, not implemented.

\emph{In my humble opinion the rawest object-oriented programming style is protoype-based programming.} Prototype-based programming is more used by dynamic languages. It keeps the design of the language minimal by having no wrappers around objects and their attributes. An object is created by creating an empty object or by cloning an existing object. Inheritance works by cloning an existing object and the subtype can replace the old attributes or add new attributes. Abstract objects are objects that will hold only behviour by containing only constant or default attributes.

\subsubsection{Functional programming}
Functional programming languages are designed around functions. Programming functions are similar to mathematical functions, that it has inputs as parameters and returns a value as output. A function should always return the same output with the same inputs and the inputs should not be changed inside the function. This leads to a particularly stateless form of programming.

Due to the stateless form of this style, functional programming languages usually support immutable datastuctures. Instead of updating a datastructure, it is copied with the new values replaced and the new datastucture is returned. First-class functions and dynamic evaluation of functions are also supported.

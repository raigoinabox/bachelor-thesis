Programming language is a formal language with a set of rules about how the
computer should behave. Programming languages usually have syntax and semantics.
The syntax of the language is usually considered the grammar of the language.
For example, if there is a syntax problem in the program, the computer doesn't
understand the command and stops. The semantics of the language is considered to
be the vocabulary and meaning of the language. If there is a semantical problem,
then the program is valid and understandable to the computer, but it is not what
the programmer wished to happen. The program will react rather unpredictably.
Syntactic sugar is a feature that the programmer can easily implement it in the
language and is there for the convenience.\cite{website:syntax-semantics}

A programming language by itself is not useful. It also needs an implementation.
An implementation is a program that evaluates the syntax of the program into
machine actions. There are 3 ways to create an implementation:
\begin{description}
  \item[Interpretation] Interpretation parses the source code and performs the
  instructions directly
  \item[Compilation] Compilation is transforming the current source code into a
  another format that can then be interpreted. Compiled language can also
  compile into another compiled language which will compile that into another
  language and so on.
  \item[just-in-time (JIT) compilation] JIT takes a hybrid approach of
  interpretation and compilation. While interpreting the program, the JIT
  compiler will observe what parts of the program are most often interpreted and
  will compile those parts.
\end{description}
Generally the compiling phase is called the compile time and the interpretation
phase is called the runtime. Compiled languages are usually considered fastest,
because compilation can heavily optimise the programmer's code, which leads to
a faster runtime. Interpretation however is faster and easier to use for the
programmer because it is a one step process instead of the two step process. For
this reason interpreted languages are usually used for scripting. JIT
implementations are usually as easy to use as interpreted implementations, but
are a lot faster. However because the analysation is fairly complex and runs
parallel to the execution of the program, JIT compilers take a lot more
memory.\cite{website:jit-memory}

Any sufficiently complex program or programming language needs to hold and
manipulate data. Because holding and manipulating only bits and bytes is
uncomfortable and prone to errors, more abstraction is required. Dividing the
data into different types will help with ease of use and early detection of
errors. A type is the upper bound of a range of values that a variable can
assume. In a typed language a variable can be given a nontrivial type while in
untyped languages a variable is not limited to a type. Strongly checked
languages will give an error in case of mistyping and weakly checked languages
will not check for such errors and might produce type-related bugs. Statically
checked languages check for type errors during compile time and dynamically
checked languages will check during the runtime.\cite{cardelli96}

Programming languages are usually divided into two categories: high level
languages and low level languages. The difference is that low level languages
are designed more around how the computer works, while high level languages are
designed more around the productivity of the programmer. Because high level
languages need to do more translation between what the programmer wants and what
the computer accepts, they are usually slower than low level languages. Another
advantage of lower level languages is that they enable the programmer to have
better access to specific operations and more understanding how the program is
executed. This is very useful when the main goal is
optimisation.\cite{website:scripting-languages}

\subsubsection{Procedural programming}

Imperative programming is a style of programming with the philosophy of changing the machine's state to the required state, which could be a file in a hard drive or a video on the screen. For that the computer executes a sequence of operations in order, which are specified by the programmer. An operation is some change of state in the computer or calculation of some data.

Procedural programming is a subset of imperative programming. Procedural programming tries to divide the program into variables, data structures and procedures. Procedures are meant to group together abstract operations so they could be reused in different situations. In this case an operation can also be a procedure. Data structures are meant to group together conjoined data so they could be moved and manipulated more easily. Variables are pointers to data. They point to the location of the data in the memory which can be then easily retrieved.

\subsubsection{Object-oriented programming}

Object-oriented programming is another subset of imperative programming.
Object-oriented programming tries to divide the program into objects that
communicate with each other. Each object has fields and methods. Fields and
methods are similar to variables and procedures, but they are tied to the
object. Fields are considered to be the objects inner state and methods are
considered to be the object's behaviour or object's
interface.\cite{website:object-orientation}

The goal of object-oriented programming is encapsulation. Encapsulation means
that each object has an inner state, inner behaviour and an interface for other
objects to use. An outer object doesn't need to know what is happening within
the object. It only needs to know how the object is going to react to an
interface procedure. Access protection modifiers are generally employed to
better enforce this behaviour. These modifiers are usually tied to a method or
field and they describe what other methods are allowed to access these methods
or fields. Right to access a field means the right to read or change the field
and right to access a method means the right to run the
method. An object's methods always have access to its objects
fields.\cite{website:access-modifiers}

An object can inherit another object. The inheriting object is called subobject and the inherited object is called the superobject. The subobject gets the superobject's fields and methods. A copy of the superobject is created and retained in the subobject. When searching for the subobject's methods or fields and they are not found then the superobject is searched for the field or method. A subobject doesn't automatically have access to the superobject's private fields and methods. The subobject can override the superobject's public methods. The type signature of the method cannot change, but the content or the action of the method is changed.

\emph{The classic way to implement object-oriented programming is with classes.} In class-based programming the object is separated into the class and the instance. The class is an abstraction and the classification of the object while the instance is a actual object with actual data. Usually the class holds the behaviour of the object, which includes the constructor. The constructor is a special method, that is called when a new instance is being created from the object. Inheritance works by remembering the inheritance line and then searching for the methods in the right class.

An interface is a a class that has no fields and all its methods are public. All of the methods are abstract methods, meaning that the methods have no content or implementation. A class can usually implement multiple interfaces but inherit from only one class. One can't make a instance of an interface, there needs to be an implementing class. An abstract class is a class that has atleast one abstract method. Similar to interfaces, it is impossible to make an instance of them. However they are still classes and and they are inherited, not implemented.

\emph{In my humble opinion the rawest object-oriented programming style is protoype-based programming.} Prototype-based programming is more used by dynamic languages. It keeps the design of the language minimal by having no wrappers around objects and their attributes. An object is created by creating an empty object or by cloning an existing object. Inheritance works by cloning an existing object and the subtype can replace the old attributes or add new attributes. Abstract objects are objects that will hold only behviour by containing only constant or default attributes.

\subsubsection{Functional programming}

Functional programming languages are designed around functions. Programming functions are similar to mathematical functions, that it has inputs as parameters and returns a value as output. A function should always return the same output with the same inputs and the inputs should not be changed inside the function. This leads to a particularly stateless form of programming.

Due to the stateless form of this style, functional programming languages
usually support immutable datastuctures. Instead of updating a datastructure, it
is copied with the new values replaced and the new datastucture is returned.
First-class functions and dynamic evaluation of functions are also
supported.\cite{website:persistent-struct}
